问题1: 怎么才能快抓住脉络呢？ 先看目的，再抓重点 重点之间的前因后果 来龙去脉搞清楚。 点 点之间的关系
问题2： git提交过程，
问题1: 提交还是没有认识深刻，某一个刻只能一个人呢
问题2: 如果你不理解一个事，你就会简单认为它是一步完成的，如果你理解深刻的话，它会是有很多步，而且还有很多分支，之后你才能感受到它的改进的问题，改进后的好处， 如何改进。 分析这么清晰，那设计呢? 也就是把别人的优点都给分析出来，那自己如何设计优秀的东西呢？

这节课给大家讲一下gitlabflow 为什么会有gitlabflow这个东西呢 我们上节课讲到 
它第一个就是  它是根据我们的开发流程来定的
第二个呢 根据我们要管理我们在多人协作的时候 或者多次更新的时候，管理我们的代码来做的
 当然这就涉及到我们在开发团队和公司规模情况下，大家可以自己来想想一下，如果你的公司可能只有一个人或者两个人或者几个人，你们做的是外包的项目，可能你们根本就不怎么需要或者  用的特别少，你们只需要把代码写完，写完之后做一次合并，合并之后做一次提交，然后编译 发布基本上就可以了，可能这个项目就结束了， 所以在代码管理这块以及代码管理和流程以及后续的发布，在持续更新的时候，就不太会用到

今天我们讲的这个流程可能是大多数互联网产品，为什么是产品呢 ，产品来说一般情况下，它会多个版本，产品它一般是一直迭代下去，所以说它会有很多个版本，我们在最早的时候 可能会 有一个beta 后面会有一个1.0版本，当然有些公司呢 它比如说敏捷的时候 每个星期会有一个版本，它的版本序列号会是1.1.1  1.1.2等，一般是三位数，之后可能会是2.0版本， 后面它每一次改bug可能都会在最后1.1.x版本，做一次大的升级 会变成2.0版本，迭代下去，
总之呢，都是在原来的代码的基础之上，不断去丰富功能 加代码过程，
此过程有一条线，这条线就是我们生产上的一个代码，它始终是跟生产合并的，我们叫它为master分支，它是有一个主干的，这是我们的一个主干，我们的代码始终是在这里
然后 我们接下来就会出现另外一种情况，最开始我们本地这个时候就需要一个线，  我们先讲最开始，比如说我们在开发beta的时候， 可能这就是我们的dev分支，也就是说我们本地 也不说本地把 我们在线上会有一个dev分支，然后我们本地呢 开发的 我们自己的一个local分支 它是在我们本地的，基于你叫什么名字 这是一个简洁的模型，这个时候呢你开始开发，当然你本地代码 最开始是从哪里来的呢？  最早我们的代码可能是从master来的，因为有人 可能有一个先驱 第一个人 做了一个初始化，然后放了一些框架性代码，放到master上去，然后你呢作为一个开发，另外来了以后， 你肯定在原有基础上去开发 ，所以你会从master上去把代码拉下来，  我们先把线上的dev分支去掉，不要搞得这么复杂，首先是刚开始第一版的时候，我们可能不会建一个其他的分支比如dev， 就是一个本地的分支和线上的master分支，，你当然会把线上额分支拉到本地 是不是，  然后我们进行开发，开发完之后呢，本地有一个新的版本，加了一些代码和功能，形成新的版本，此时要把本地新的版本，提交到master分支上， 此时有一个提交的过程，这个过程肯定是会有一些 合并的，为什么呢 就是说你在开发，其他人也在开发，
因为一个master对应多个local分支 当多个人同时从一个master版本拉代码，各自进行开发，各自开发完成提交，提交时实现是先后提交的，比如当a先提交，此时master上的版本和a最开始从master拉代码时的版本是一致的，提交成功，之后b提交，此时master的版本就和b最开始从master拉代码时的版本就不一样了，产生了冲突，此时主干master分支已经产生了变化，因为a已经向master上提交了代码，所以要在b提交的时候，git会提示有冲突，它会把master上的分支拉一份到本地，然后做合并，在本地合并好之后，在提交到master上 这样的一个过程，这个是git会给我们提示的 这样就保持了master上的代码是最新的。 
提交过程，git会从master上拉一份最新版本的代码到本地，与本地的代码比对，没有冲突，可以直接提交，有冲突，合并之后再提交。
这说明了一个什么问题？

最开始 a提交之后，b提交之后，此时master上有一个最新的版本， 此时用这个版本编译，发布出去，就是产品beta版本，完成了我们产品第一次上线， 之后我们就开始迭代了，

这是我们最早期的原型，当我们线上一个版本都没有的时候就是这个样子的 我们只要master分支就可以了
然后直到我们产品第一次上线了之后， 之后我们就开始迭代了，这个迭代就产生了不一样的情况，因为我们不可能随便在master分支上  接下来我们要做1.0的版本 在beta的基础上做1.0，这个时候我们就不能够再随意向master上去提交了，因为万一你提交错了，就是线上的代码 master的代码就要回滚， 
比如说此时线上版本，也就是master上 是beta版本，此时a想master提交了一些代码，我们如果直接提交到master上去  测试会进行测试，测试完之后，如果有问题的话，继续再改，但是这个时候就会一直影响我们master，如果此时b要提交，会有问题，在a的整个master 提交 合并，测试完成之前，不能提交，也就是说这个时候master主干就会产生大量的拥堵，因为某一刻只能一个人占用master，而且他是线上的代码，非常危险，
问题1: 提交还是没有认识深刻，某一个刻只能一个人呢
问题2: 如果你不理解一个事，你就会简单认为它是一步完成的，如果你理解深刻的话，它会是有很多步，而且还有很多分支，之后你才能感受到它的改进的问题，改进后的好处， 如何改进。

所以这个时候产生另外一个分支叫dev或者release，
release分支是什么样的呢?也就是在master和loacal分支之间，加一个分支叫做release
它是在你每一次要决定开发的时候，它是从master上拉过来代码，你比如说此时release是基于beta版本开发，release分支就会从master上拉一份beta版本的代码到release，  然后呢a和b  我们假定我们现在同一时间只开发一个功能，这是上一个版本的进阶，现在团队两个人a和b，同一时间只会开发一个功能，不会开发多个功能情况下，用此时的结构就可以了，一个master 一个release 两个local分支这样的结构就可以了，  这是一个简化版的结构，如果是你不会同时开发多个需求，并行去开发的话，这样就可以
我们这里有两个人，把代码从master拉到release之后呢， a和b会把release上的代码拉到自己本地， 然后进行各自开发，开发完之后呢，就提交代码到release，其实相对应来说，你可以从release环境拉一个测试出来， 用它去发布测试代码 去测试， 如果a开发的慢，可能赶不上这次发布，它就不上线了 也不用做提交， 这个时候就只测试b一个人的代码就可以了，
本次开发，a先开发完，然后提交到release上，b随后也开发完了，此时b也提交到release上，（提交过程），最后用此时的release环境搞一个1.0版本的测试环境出来， 从release上拉代码，后面呢我们还会有一个什么情况呢？  就是我们  它会测试你这次开发的功能，以及之前的功能做回归测试，然后开发完成之后，可以用release上的版本 打出包进行发布，这个时候呢，你要测试通过嘛，测试不通过 有bug的话，那开发人员就应该在此时release版本的基础上再进行bug的修改，改完bug，在提交一个版本，，修复完bug之后呢 测试通过之后， 以测试通过后的版本进行发布，发布到1.0生产环境，
这个就是我们的一个上线，上线完之后，我们接着要做什么，我们要把此时release版本合并到master上去，此时所有本地开发的代码都在master和release上保存好了，保存好了之后，其实你本地代码就可以删除了，这种环境就是属于我们在中间做功能开发的一个情况

接下来 为什么我们需要一个release分支呢，大家说我们不用release 直接用master不行吗？  这种情况下会有一个问题因为我们通常还会有一个地方，如果我们线上如果万一出了一点点小问题，我们叫hot更新。热更新 就是在这种情况下，我们要做一些改动， 
线上如果出现一个点错误，我们要修复，比如说此时master是线上最新的代码， 然后release是现在正在开发的分支，要修复线上的错误，你从哪个地方拿代码修复，在哪里修复，你不能在此时的任一本地分支修复，因为你本地包含了你正在开发的代码，这个时候是不能提交到线上去的，因为他们还没经过测试，
所以呢此时会有一条新的分支，拉出来叫做hotfix， 比如说此时线上是beta版本，master是beta版本， 此时release和local分支正在进行1.0版本开发，此时线上的beta版本产品出了一点问题，此时出了问题的代码我们可以从master上拉取过来，拉到Hotfix分支上， 我们在hotfix上去改，改完之后，再测试，此时测试时线上测试，beta1.1测试，测试完之后，发布到线上去，此时我们在1.0发布之前，我们又做了一次发布，改了bug，此时hotfix分支代码也提交到master上去，此时master版本为beta1.1，
此时需要把master分支上的beta1.1 同步到release分支上去，为什么，因为你不同步上去，你下次开发完成之后做发布的时候，就会把hotfix修复的代码，给覆盖掉（为什么会覆盖呢? 因为dev测试完之后直接发布到生产环境了，虽然之后会提交到master分支，但生产环境没有了）， 这是一个非常危险的事情，所以我们必须在hotfix改动完后，把它同步到release环境下， release分支有了hotfix分支的代码之后，我们后面会一直进行测试，然后去发布，这就是我们在团队开始升级之后，就是我们的产品开始一步一步做改动过程，这种方式呢基本上在只有一个开发团队的时候 是没有问题的，一个开发团队你肯定是同时开发一个功能，
最终极一个版本就是gitlibflow 官方推荐的一个最完整的流程，前面两个都是我们简化过的，最完整的一个流程，就是在我们有多个团队同时开发多个功能的时候，我们要做的一件事情是会比第二个版本更复杂，
我们来了解下，大家可以理解为这三个流程 三个开发流程 因为像第二个流程是它是用来做一个团队同时开发一个功能。
在第三个流程中 可能是三个团队同时开发三个功能，三个功能的发布时间是不定的，可能会有先后顺序，或者是没有先后顺序也有可能，但是这个时候绝对不能在一个release分支上开发	。比如说都是release上开发，最终情况可能是比较惨，就是一定要等这三个团队全部开发测试完成 这个功能才能上线，但是其中有个团队的功能可能比较简单，早期就开发测试完了，但它不能上线 ，这个时候就会严重影响业务的效率，所以在这种情况下我们会如何来做呢，会新开出来一个feature的分支 
此时有一个master分支 hotfix分支 dev分支，release分支  feature1分支，feature2分支， feature分支是功能分支，不管是一个人开发还是两个人开发， 一个feature一个团队， feature分支开发完成之后，提交到dev分支上 当然feature分支可能有自己的测试，feature开发完之后呢，会往dev上去合并，合并都dev之后呢，它就会进行测试， hotfix还是和之前一样，从master上拉取代码，然后开发，开发完之后 合并到dev上，dev最后用来发布 ，但是发布会不一样，我们会再建一个release分支，用来发布，从dev获取代码，到release分支，通过release分支进行测试发布，当然就是说当我们决定要发布的时候，去建发布分支，把dev上的代码获取到release分支上，由release分支来进行测试，当然如果此时feature2开发完了，但是featrue2其实已经错过了时间节点，，此时feature2分支把代码提交到dev分支上，  当然这次的发布不包括feature2的代码，feature2的代码要等到下一次发布，也就是说dev分支上的代码很多情况下都是，超过master的 ，当然我们做好发布之后，feature分支可以废弃了，当然非开发完成的feature分支要保留，feature2 在向dev分支做提交的时候，首先要拉一份dev上最新的代码到本地，做完合并，再提交的， 也就是在多个团队开发多个功能的时候，流程要非常严格，否则会很容易出现混乱的状态，所以要严格按照流程来走，当然后有时候 我们漏了一个问题，就是说 我在release分支测试的时候出现了问题，有bug，有bug的情况下，我们的建议是 还是在原来的feature上改， 改好之后  合并到dev上，这个时候合并会经过两个步骤，一个是从你自己的分支，合并到dev，然后再从dev合并到realease，会比较麻烦一点，你可以直接在dev上改，改好之后，直接合并的release上就可以了，   当然你需要是把dev代码拉回自己的feature分支上，除非你觉得，因为改bug相对来说会比较快， 半天就可以搞定， 所以他绝对是不可以影响release 分支的，或者release的时间，所以你可以在feature上去改，改完之后提交到dev上，然后由dev在合并到release上，，release上做最终的测试，release它一定是本次发布的内容， 
而这就是今天我们给大家 讲的  第三种流程比较复杂，中间每一次 合并的过程都需要做审查和check，会涉及到相关人员  以及代码整个测试 开发测试 校验 验收等等环节，
我们这节课呢 就是给大家讲了我们用gitlabflow 搭建的三个流程 在一般情况下，终极最复杂的流程 多个团队并行开发多个功能情况 包括个人直接用master分支来做，以及我们中间加了一个release分支 没有feature分支的情况，这三个流程基本上就适用了，但是我们只是讲了下流程，大家要通过自己去实践包括代码不断去拉，合并，做分支去实践，才会去更好地理解   