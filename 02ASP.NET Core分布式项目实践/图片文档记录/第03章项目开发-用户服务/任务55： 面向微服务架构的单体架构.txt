
 问题6：概念理解清楚，应用场景理解清楚，事情的发展过程也要清楚，这是梳理业务过程， 存在问题就是概念缺少或理解不清楚，应用场景不清楚 如发布订阅，内存级别

我们接着来讲面向微服务的单体架构 
问题1：一个东西的优缺点及如何应对？，应用场景  业务的聚合度  技术选型 开发效率
在我们微服务化之后呢 微服务它能带给我们的好处是 很大的一个好处是 我们可以在拆小之后呢 业务的聚合度比较高，就是一块业务放到放到一个地方，这是它的一个优点之一，还有第二个优点是 因为它独立之后 这块业务它的技术选型 技术栈包括其他中间件 基础设施 数据库 持久化这块 选型都可以自己做决定， 所以相对来说 选这块业务合适的技术，这对开发效率其实是有帮助的， 但是我们要想利用这两个优点呢 就要屏蔽它的另外两个缺点 就是因为服务化带来的下面的问题 ，

问题：采用微服务后，如何去发现问题 理解问题呢？
 1.分布式所带来的问题， 大家都知道分布式带来很多问题，如问题追踪，测试 ，部署 监控 分布式事务（一致性）这些都会在微服务架构里面出现  测试我们会引用容器，在本地快速  因为 你想你有很大一微服务之后，如你只测试你自己的微服务 一旦你的微服务有其他的依赖的微服务的话， 那么你测试起来 必须报另一组服务也启动，所以相对单体来说， 你一下运行就可以把所有的都运行起来，不会出现什么依赖还没有启动之类的，所以在这边会产生这样的一些问题，
 2.服务治理 还有服务变多了之后会出现 服务治理的问题，比如说我们现在有一百个服务 我们怎么样 在客户端那边 怎么样去调用 不可能是有100个地址，直接都丢给客户端，这100个地址是干什么的 是否是可用的状态，这就是服务治理上做的 服务发现和服务注册 包括服务的跟踪 都会遇到这样的一些问题，
 3.开发难度加大 聚合查询 还有一个是在开发上遇到的比较大的问题是 聚合查询， 导致开发难度加大，体现在聚合 也包括分布式事务，

 问题2： 敢于尝试
 这些问题还是很大的，但如果是单体就不存在这样的问题，所以我们能不能把微服务和单体这两者来结合，做了一次尝试之后发现其实也没有那么的复杂，其实比较简单，我们还是在单体的结构下去拆分，我们在单体架构中 api还是我们的webapi项目，其实里面会有我们的拆分的各个controller 如Usercontroller ProjectController等，

 问题3： 先模仿，
 单体中的usercontroller对比下微服务架构下的User， 因为先写的userapi，  微服务化后 我们会做到尽量的简单，特别的简单 简单到最开始从零开始写这个api的时候，不需要考虑太多的层， 建api，建bll 建dal，如果这样做的话 可能失去了微服务的意义， 有一些api其实它就是特别的简单。就是你在controller里面 直接把 dbcontext拿来直接用就完了，可能就没那么复杂，你一个User的api的几个方法可能真的是一个小时就完成了。 那我们为什么还要搞那么多复杂的事情，就建各种bll dal，各种接口在哪里呢 对把，只要我们能满足业务需求，并且user的api就在这里独立维护，跟其他人也没有什么关系， 可以独立部署代码还很清晰简洁， 这就是一种很好的方式，

 问题1： 微服务和单体结合，如何结合？ 结合什么呢？
 所以在我们把这个微服务拆成单体之后呢  其实我们就会把各个api项目合并成一个api项目，合并后的api项目中的各个controller之间没有调用的，我们还是会沿用微服务里面的这种思想 就是我的usercontroller里面他其实相当于有一个聚合的 或者由一个bounded context 它usercontroller里面只放user相关的事情， 其实相当于我们先把这个框框给画好了（也就是业务拆分好了） usercontroller只放用户相关的事情，你可能会问用户里有哪些东西呢？对不对 这个其实就是在api设计的时候考虑到， 我们好像还没有开始讲， 我们下节课开始写用户的时候，在给大家讲， 就是这个领域这块的业务逻辑， 
 简答来讲，我们现在其实就是说 把业务都已经拆分好了， 我们已经知道用户这块会包含哪些信息,包含哪些表 哪些功能 对不对，  给大家简单说下 如果大家还记得我们业务 我应该不要这样问了，你肯定必须要知道我们的业务是什么样子，我们的用户没有太多信息，api设计呢  先给大家看下，我们还没有给大家讲设计，
 这个是已经全部开发完成的api设计 用swagger来显示的  我们在用户这块api呢 获取用户资料 更新用户信息（patch） 获取用户标签 上传名片  名片这个信息其实跟数据库还没有关系，他只说调用腾旭的ocr识别的接口 去把名片里的信息 识别出来， 获取用户当前的bp列表 上传bp列表 获取系统推荐的用户 这个其实也是一个额外的一个接口， 就是在登录之后出现的页面，用这个接口返回数据， 
 在这个地方严格来说它只有两个接口，一个是获取用户的资料，还有一个是更新用户信息 也就是我们的 我的模块 显示和更改个人信息， 大家可以看到这里有很多更改信息，还不在一个页面 我们用一个接口来完成的，在http 协议中 patch的东西  
 
 问题4： 配套工具要有的
 给大家看下postman  我这边把所有接口的调试保存在postman里面， 测试的时候会给大家详细介绍 应该可以使用这样的方式，在调试的时候也会很方便 ，它里面有个conllections可以把我们的测试保存起来， 所有的api调试都保存在这里

 用户呢 用户非常简单， 我就只有一个获取用户资料和一个修改用户资料，当然可能说会出现，所以说  我们在单体的情况下， 我们就只需要在usercontroller 写了两个方法 还有其他的方法如上传名片等，它是全部在用户范围之下，
 当然还会有一些信息，比如说  我们给大家看下 我们的api在其他地方 可能需要查询下用户，比如说在我们的contact 联系人的地方， 我需要查下用户， 所以这个时候 相当于 我们会有一个聚合服务出来，在我们微服务的情况下， 会有这种问题， 用户服务和通讯录服务之间 在调用通讯录的时候 会需要查询到用户服务， 我给大家看下具体的场景  在聚合服务里面（注意聚合服务是啥意思） 批量添加好友的时候， 你这时候它会 用户会把它手机里面通讯录给上传上来 一次性会上传几百个号码， 但这个时候你就需要判断的是  有一个场景在这  就是那些用户已经注册了呢？  对吧 那些用户已经注册了 其实你这个时候需要去调用user的api， 有一些是已经是添加了，有一些没有添加  这个时候还有一个判断是 这里没有体现出来 那些是系统用户 那些不是系统用户，这个地方跟微信 大家可以看下 自己手机微信 通讯录  添加的时候一模一样，你可以会找到手机通讯录里面 那些是已经注册了微信，那些没有注册微信，他都会有标识，这时候会需要到用户库里面去判断，那么就会出现 这样的一个场景。在通讯录里面他需要去查下，用户api，对吧， 
 问题：出现了问题，
 这种情况就比较复杂，有时候会变成通讯录调用用户 用户调用通讯录甚至是用户调用项目，项目调用用户，就会让你整个 当然用户调用变得 让你的整个api 看起来比较杂乱，两种调用一种是基于文本的 同步的，还有一种是异步的，我们现在简单的来做，在这种服务下 有几种模式 稍后我们会给大家讲， 
 问题： 解决办法
 我们现在用的这种方式是聚合服务， 怎么来立即理解呢？就是我用户这块 它有一个单独的服务，只负责用户这块， 还有通讯录只负责通讯录这块，有一些在通讯录里面的服务 需要调用到用户的地方， 这时候怎么办呢？ 这个时候我们再另外开一层出来，（注意是一层哦）叫聚合服务，可能在这个地方 它的聚合服务属于这一层的 比如说这个聚合服务匹配通讯录，他其实是属于通讯录这块的聚合服务，它呢会先调一下通讯录， 再调一下通讯录， 他自己会把这逻辑处理好， 就会少了很多服务间的调用，相对来说  早期的时候 业务不是很复杂，微服务架构这种方式，足够处理了， 让我们各个服务 就会特别简单 看起来比较清晰， 而聚合服务就是专门用来做  涉及到跨多个服务调用的这种处理，我们在单体的时候呢，其实就是我usercontroller 只负责用户服务这块， 但是我有一个AggregateControllers 他里面有个ContactController 在这里面 它调用了  userservice和contactservice 它做了聚合，而这个聚合在微服务架构的情况下，它是调用api的，而我们在单体架构中它是调用dll  就是把所有和用户相关的逻辑，封装在我们的dll里面，所以大家看我们在user的dll里面，其实它的context  model都封装在这个dll里面，其实也相当于我们再做了一层处理，大家会看到我们在 我们的聚合服务这个时候其实就没有那么复杂了，就没有说跨service去调用（也就是远程），我们只是简单的在dll之间引用， 也就跟我们之前ui层调bll dal一样，所以没有太复杂， 这种情况下，对我们早期开发  包括开发的效率 稳定性 都是有一定的保证的， 
 这是在聚合层 这块，还有另外一层处理就是我们在单体架构上，也用到了cqrs，但是这个cqrs就是跟我们在微服务架构里面cqrs呢会不一样， 微服务下的cqrs 我们涉及到要用到rabbitmq，要加一个队列进来， 同时有多个worker 去消费这个队列，它已经涉及到多个进程了，不同服务器上的多个进程，我们在单体架构上是一个进程内，一个进程内 也就是说 你也可以用cqrs，其实就是我们用发布订阅这种方式， 比如说我用户里面会有一个userCreatedEvent：IRequest，相当于我的用户创建成功了，大家别忘了我们后面才会给大家讲，详细讲的 就是我们会把用户数据进行冗余， 这在我们微服务  我们用面向微服务架构的方式去开发的时候 带来的一个问题， 我们虽然没有api化，但其实我们做了拆分，拆分完成之后呢， 用户会用自己的数据库，通讯录会有自己的数据， 项目会有他自己的数据库，我们其实数据库已经全部拆开了， 那但是就是用户数据做了冗余， 因为我们项目里面也需要用到用户数据，这个时候我们不可能做表的join， 我们做了冗余，就把用户数据放到了项目上面来了，用户的一些姓名 头像 这个时候我们通过项目查询的时候呢  大家别忘了 在查项目的时候，其实是可以看到项目创建人头像和电话 这些信息就是机会这个api返回的，他没有去查其他的数据库， 他查的就是自己数据库，这个时候它就有用户的数据冗余到里面了额，冗余过去之后呢 这个数据在用户更新的时候  我们现在只有创建，创建的场景是什么呢？ 创建的场景是 当你用户创建过之后， 这个地方涉及到我们调用了消息服务，我们用的是融云，在你的用户创建的时候，你需要给它发一个消息，去拿一个token，就是用户注册，否则的话，它接收不到IM上的一些消息，，所以在用户创建的时候呢， 如果你是一个分布式的情况下，你会产生很多的event，把event发到队列上， 然后会有worker 去执行，worker处理完后，有点是写入到db，有的是发了网络请求发到别的地方去， ，在我们这个地方呢，用的是一个叫MediatR的框架，

 问题6：概念理解清楚，应用场景理解清楚，事情的发展过程也要清楚，这是梳理业务过程， 存在问题就是概念缺少或理解不清楚，应用场景不清楚 如发布订阅，内存级别


 问题7：MediatR之前我也看了，但看了不理解，不知道用到什么地方， 不知道怎么用是不是业务流程不清楚呀，
 这个框架 在github上可以找到， 非常简单， 内存级别的发布订阅，基本上属于一看就会的，所以特别简单，github上有一些简单的实例，已经足够了， wiki，大家看他的使用方式，

 首先你要定义一个Event  string是期待的返回，
 public class Ping : IRequest<string> { }
 然后一个Handler 当发送的时候 由它来处理，
 public class PingHandler : IRequestHandler<Ping, string> {
    public Task<string> Handle(Ping request, CancellationToken cancellationToken) {
        return Task.FromResult("Pong");
    }
}
最后把event发送出去  eventhandler就会被自动执行
var response = await mediator.Send(new Ping());
Debug.WriteLine(response); // "Pong"

问题9：解耦啥意思呀，看到这名字，心中没有对应的图像呀
这发布订阅就非常简单，在内存级别使用就可以了， 相当于可以给我们解耦 就是我们很多的应用， 后来我们会把这个发布订阅 替换为rabbitmq方式，rabbitmq不是在内存级别， 但是我们所有的代码已经很天然的是这个样子，到时候 在微服务架构下，我们就会有些地方替换成rabbitmq，然后会用到消息队列，现在这种方式 是内存级别的 ， 关于这个架构方式呢不是我们课程的主要内容， 主要内容还是要以微服务为主， 这里我只是给大家多增加了一个概念，一个观点 大家可以自己思考下这种方式，如果有什么问题？ 大家可以在群里来进行讨论交流，然后 主要还是把精力放到微服务架构下，之前我开发方式是先把单体写完了，然后微服务写了一半， 现在你们可能开始先写微服务， 写完之后 你可能会大概清楚  你微服务已经写完之后， 你现在再回过头去想，如果你不是写微服务， 微服务写起来太慢了，然后你就要写单体， 你这个时候，再去写单体架构的话，怎么样来写， 其实的思路也会很清晰的，
本节课就简单给大家讲这么多，然后下节课我们开始写，按照我们目录计划，我们开始写我们的 应该是登录这块， 因为他是基于手机号和短信验证码就可以完成登录，获取token，并且我们对于移动端 会用到reflush token， 因为他的过期时间嘛 所以会给大家先讲下， 这个地方也是用identityserver4来实现的，所以算是对第一章有个复习和总结，这里我们需要自己扩展一个validate