
还是有很多琐碎的小知识点不知道，以及经验不丰富，处理问题没经验，虽然是想通了抽象的东西，但是具体的的东西，还是欠缺很多，这里心理上要有准备。
我的偶像呀，腾飞真牛逼呀，理解 真透彻，讲述真透彻
问题1，还是有些常识，没了解，如应用层，接口层，业务层，
问题2。激情在哪里，效率在哪里，反思在哪里，思考在哪里
问题3, 有些一听就明白，但是让自己去学，可就没这个效果了， 以前自己认真学为啥也没这个效果呢。

大家好，这节课呢，我们开始写这个 用户的api，然后，在这个 写这个api之前呢，我们需要 就是说，其实我们还没有开始任何 api的设计，那api的设计有两种，一种就是说我们可以用这个 借助一些工具，这个工具包括有 像这个swagger，也是工具之一，那swagger这个文档的生成有两种方式，一种是你可以手写这个yaml，他也是基于yaml可以生成文档，还有一种呢是，就是，你先写代码，写完代码之后呢，它可以根据代码来生成这个文档，但是你要先写代码的话，这个接口的设计，其实它是滞后的，也就是说，它是 你写完之后，才有的，那么在这之前呢，你的思路或者你跟别人交流这个东西就没有，没有一个东西出来，所以，我们看下，在  这个是代码写完之后，swagger生成的一个文档，地址：111.231.111.243/swagger/#/Contacts  我们在用户这边一共有6个，其实相对 对比来说 我们用户身份这块 我们没有再去细分，在这个里面呢，我们会有那几个块信息呢，一块是这个，我们可以讲它叫UserProfile，其实就是资料这块，，然后呢，我们 还会有它的这个TagsData，这个TagsData呢他其实不是，它是用来，它是一个选项，就是每一个用户，会有自己的一套这个标签，标签数据，然后呢，我们还会有这个BP，我们把BP放到这个地方了， 还有一个是名片，名片呢，其实我们在这里，他只是用来做一个，其实用来更新userprofile的 ，所以，其实我们可以不用在这里列出来，

问题1：什么是应用层东西？
namecard只是说通过一种上传名片的方式，大家可以把它理解成T它是应用层的一个东西，就是，他其实是根据namecard 去把它的这个userprofile去更新掉，当然我们会，所以我们会把userprofile bp tagsdata三个东西放到用户身份领域， userprofile bp 两个有get和更新，tagsdata呢我们现在只有获取，为什么只有获取呢，因为我们现在在Ui上还没有一个可以去，或者说在我们业务层面的话我们决定，不通过UI去更新这个tags，没有一个添加tag的地方，就是没有直接增加tag的地方，而是通过给用户打标签的时候，在哪个地方再去新增，当然哪个地方其实我们就不会说单独在通过，大家可以想，就是说， 我就不会通过UI，给这个，在个信息-他人打标签的这个地方，也就是说这个地方，首先第一个我们先获取一个 获取一个用户标签列表，是当前用户的，然后这个时候，获取已经给用户打的标签，，这个时候我们可以再新增一个标签，这个标签是在目前的标签列表不存在的，这个时候点完成，点完成之后，会做两步动作，第一步动作是，首先把这个没有的标签，添加到当前用户标签列表，第二步是再给这个好友 打上这个标签，这两步呢，当然我们不会去由前台调两个接口来完成，这样的话，前端的兄弟可能会要和你打架，为什么你不搞成一个接口给我，对吧，那我们就给他封装成一个接口，，

问题2：接口层面的逻辑，之前的认识是 每个层的方法都一样，以及之前完全就是调用接口，没有涉及分布式，分布式就是要通信，之前不涉及到通信，
当然这个是，其实我们来讲，它是属于接口层面的逻辑，其实在领域层呢，，我们不是这个样子的，就是我们现在要分开，就是你能理解哪些是接口层的逻辑，哪些是领域层业务层的逻辑，业务层的逻辑其实在我们的tags地方，还是有一个add的操作，它是在用户这个领域下的，那么，我们在这个，通过通讯录这个地方 打标签的这个地方呢，会去调用用户身份领域的一个添加tags的接口，当然我们在这个地方呢，要通过什么样的方式去添加呢，我们其实不是通过api来调用，我们是通过 就是叫事件订阅这种方式，在 rabbitmq消息方式来走的额，，内部是用消息来通信的嘛，，除了有一些查询是可以直接去查，但更新的话，我们基本上都是说，直接走的是消息的方式，我们没有走直联的这种方式，好，那这样的话，我们先给大家讲 就是我们在这个地方会，在tag这块它会暴露出了一个获取tag的一个接口，而不会暴露出一个就是更新或者说新增一个tag的接口， 所以在这里呢，而我们是通过另外一种方式就是事件队列这种方式，来完成更新的操作，我们先在这里来写，后续我们再讲 写到这个地方（通讯录）就会给大家讲，这个其实是说，我们讲到另外一层东西，最开始上节课时候，我们讲了微服务的这个聚合，就是你在查询的时候，会有两块，不同的查询方式，一种是聚合查询，还有一种就是，我们说一种是我们把数据冗余在我们这个地方，他直接去查询过来，而不需要去跨service去查询，还有一种就 可能是搞一个api，然后调两个api，再组合数据去封装 这种不同模式， 而更新呢 有很多种，更新呢有直接同步更新，就是，比如说，通讯录领域去调用户身份领域这个的api直接调用，还有一种是异步的方式，异步的方式就是我们走一个消息，然后消息到队列里面去，通过这个订阅的方式，发到用户身份领域这边，这边拿到之后，根据消息去更新这种，这样两种，
好，然后我们接下来呢，再接着说我们这个用户的api。两种方式，一种是swagger 它是在写完代码之后生成的，当然你也可以自己写yaml，提前来生成，你是可以写一个yaml的配置文件，他自己也可以生成，但是那样的话，用yaml来写api其实效率也不是特别高，所以有一部分开发人员不愿意先用yaml写api，另外一种方式就是excel。excel相对来说，就是表格，它会比较容易一点，其实我们用excel，两个作用，一个是我们事前的自己的分析，就是你自己怎么样心里有个数，比较快速的方式，，用最快的方式把心里想的东西列出来，然后去对比，也是一个设计的方法，另外一个目的稍微拿着这个东西跟大家做一个讨论，它不是，excel它会有一个很大的问题 就是更新很麻烦，就是往往我们excel最开始定好了，后面时候呢就不更新了额，就我们改api改代码之后就不改文档了，也就是文档不是最新的了，这种问题也时有发生，所以一般情况下，我们在最早进行讨论时候，用简单的excel写一些接口信息，两个目的，第一个自己头脑里思路的一个过程，第二个是做一个简单的沟通，那至于说这个沟通是设计层面的沟通，并不是说就是很细致的那种，而到后期的时候呢， 大家以规范 或者查阅，包括跟前后端这种，其他的一些系统正式对接呢用swagger，就是他直接根据代码更新，也比较合适，所以可以采用两种方式
那我们首先来看下用户 我们提供的接口，获取用户资料和，更新用户资料，搜索用户，获取用户标签列表，，bp呢，我们这个地方没有列出来，我们可以写下，获取bp列表，然后，上传bp文件，这个上传bp文件，在我们的app当中，用的是又拍云，它会直接把这个文件上传的又拍云上，然后传给我们一个文件地址，所以我们拿到这个文件地址，进行 保存，当然我们在  bp文件在移动端，ios上直接是可以通过下载到本地，通过浏览器来预览这个pdf文件的，包括一些excel其他一些文件，他也可以预览，但是在安卓的情况下，支持不是特别好，所以我们可能会在后端做一个转换，就是把你这个非pdf文件，转换成pdf文件，这样的话呢，移动端下载下来的话，直接在我们的app内查看，设置下路由，post或者get方式，获取用get，上传用post。 两个都是/users/bpfiles 一个是get，一个是post
那上传名片接口呢 我们可以看到它的post里面我们传了哪些信息，地址， 返回的参数，返回的参数其实  这是我么已经定义好了， 根据我们的这个，上传名片的ui，来定义的，也就是说 我们会返回名片上面的手机号码，姓名， title也就是你的职位，公司名称，公司地址，邮箱，以及公司的电话号码，，这个是我们返回的body，直接以json的形式去返回，然后我们，这个地方，要给大家讲下，关于，restfull的api设计或者  有一些开发团队包括我们之前也自己做过这种 就是，会在统一的返回文档里，加一些这样的东西，比如说，有statusCode这样的玩意，1或者0表示它正确或错误，同时呢还会有一个message来表示错误的时候的messgage，之后再有一个data是一个数组，返回的是正式的结果，这种情况下呢，就是说所有你的数据格式，是统一的，全部是这样，不管你这个api是正确返回结果还是 是运行正确还是运行错误，还是说有业务逻辑的问题，那全部都是这个统一的格式，那我们遵循，这种情况下，前端有时候，就是正确的情况下，他需要进行一次这个，把data拿出来，然后错误的话，它就拿statuscode和message，而我们现在，在我们定义的这种处理方式情况下，是什么呢，就是，大家会注意到，在这个地方（这种返回格式下）其实后端封装起来会有点麻烦，每次都要封装除了data外其他的东西，而且正确的情况下，也要封装这样的东西，其实没有必要，我们在这个地方呢，如果正确的情况下，我们就严格定义了你的api返回的情况，你必须注意到，我们可能有时候，不会太注意你的http status code，到底返回什么。就是你如果，有时候我们是一个错误的时候，像这种情况，所有的api都会返回200，对吧，因为，即使我是错误的，但是我通过statuscode和message 返回给你，告诉你错误了，所以它的http status code 还是200， 基本上很少有400
这样的情况，没有 那这样的话，前端其实每个请求，他都必须拿过来解析下，对吧，并且要判断下你是正确的还是错误的， 
我们今天采用的这种方式呢，就是说，只有当我正确的时候， api返回给你的一定是数据，它才是200，任何 只要有任何的错误的情况下，都是400或者其他，也就是非200的statuscode，大家都应该知道
所以我们在这个地方呢，只有正确的情况下，才会返回200，其他情况下，返回错误， 那么正确的情况下，客户端拿到是不用做解析的额，这个数据就是它要用的数据，只有当错误的时候，我们才会返回这个statauscode和message数据，这也是一种约定，，其实我们在asp.net core api里面 也是这么给大家定义的，
好，所以我们在这个地方先给大家讲了这个结构，关于 比如说这个是上传名片，我们会这样返回，正确的情况下，返回data，错误的时候就会报异常，里面会带message，然后这个异常信息呢，message里面是分的，一个是当我们是develop环境 就是develop的话，我们会给你包含堆栈异常信息，，如果是正式的情况下，我们是不会给你任何信息的，就是一句内部错误，防止我们这个异常信息会泄露到一些关键信息，造成一些安全上的隐患，
那，讲到这里之后呢，我们再回过去看下我们的api，这些api呢，都是结合我们的这个，之前的类图，就是用户要返回那些字段信息，
上传名片，获取个人资料，更新部分个人资料，搜索用户，获取用户标签列表，获取bp列表，上传bp文件，这几个接口呢 基本上来说把 user和userproperty和usertag和 bpfile 给涉及完了，，然后接下来，就是说，我们会涉及到，我们首先可以把我们的这个EF，因为我们用的mysql，我们用了ef的models，可以给他建好，在之前我们只建了一个很简单的user信息，

docker等我们user.api全部写完了，才会用到，

这节课就是给大家 先大致讲了下，我们接下来要写的7个接口， 大致上要说的post，像异常处理，异常处理，我们后面还会讲， 就是在我内部哪些是异常，然后什么样的异常，去返回什么样的信息，也会给大家讲，现在先简单给大家说下， 我们是这样来处理的，我们并不是全部返回统一的格式，
下节课，接着完成建模

