 开始时间2：20

问题1：注意效率
问题2:soa流程不清楚，当然这只是个例子，还有很多概念不清楚。概念流程不清楚
问题3： 对现象的流行 缘由不清楚，  
问题4：采用新方案带来的优缺点， 也是事务的演进 不存在这样的概念
问题5： 为什么我不能得到这样的结论呢？ 事前很难想到，看到后又觉得很简单。 如越来越难加新功能 加新功能越来越慢，
问题6:如何自己总结出事情的演进 逻辑，乃至结果，
问题7：察觉出问题
问题8：有前瞻性的思考


 这节课来介绍下微服务 上节课我们讲到单体演进到最后的阶段之后，要进行业务的拆分，那么业务的拆分 其实我们已经在做一件服务化的事情，而服务化与微服务的区别其实相对来讲 在我们微服务诞生以前呢 在做soa架构的时候，已经是服务化，那么只不过呢 在soa和微服务之间的区别在于界限也比较的微妙，我们今天不太去涉及到soa 大家更好的去理解微服务简单的来讲呢？ 微服务是什么？ 我们首先来讲它有几个特点

 微服务的特点
 业内比较有名的两个人 是跟微服务关系比较大的 一个是马丁flower，他最早在他的博客上 写出了关于微服务的 名词的定义 那么第二个是 netfix的架构总监 它呢一直从头到尾 在netfix 从单体演进到微服务架构 从头到尾都参与了，它呢对微服务 也下了一个定义 那么简单的来讲呢 就是loosely coupled service orientted architecture with bounded context 怎么来理解这句话呢/ 就是说它是一组小服务 也就有了我们第一个特点 它一组架构风格 是松散耦合的 也就是说它们 服务之间没有很强的依赖关系，不是一定要说服务有我才能开发 没有我开发不了，


 问题2:soa流程不清楚，当然这只是个例子，还有很多概念不清楚。概念流程不清楚
 在soa里面就是 面向服务架构里面 很强的一种说法就是 它自上而下 我必须先把每一个接口先定义好，每一块接口的契约是什么 定义好，然后你在各个模块之间  独立的模块之间 进行交互的时候 按照这个接口定义来，所以他们之间是有很强的 依赖关系，
 而在微服务这一点呢他主张的是松耦合，就是你们服务之间最好不要有什么依赖，比较独立一点， 然后呢是  微服务也是面向服务的，当然它是with bounded context 也就是 我们在ddd 领域驱动设计 里面所讲的界限上下文 ，那么关于这个概念呢 我们要在ddd中去讲，大家简单理解就是它是 相当于 用来去指导我们去划分业务的一个标准， 它里面会一个bounded context里面会有一个聚合根，还有其他的领域模型之类的，  好然后 我们来理解松散耦合 的soa架构的基础之上，我们在来理解微服务，
 这个服务有多小呢  其实就是参考bounded context  也就是为什么在领域驱动设计 其实好像一直不温不火，有一种被人遗忘的感觉， 突然一下就冒起来，也是跟微服务有关系，因为按照领域驱动设计里的bounded context 来进行微服务的划分 对一组小的服务有指导意义  因为如果没有一个指导的话 大家不知道服务应该有多小，应该怎么去拆分，所以这也是为什么这两年ddd突然一下子 在社区里的声音又看到了
 问题3： 对现象的流行 缘由不清楚，


 1.它是一组小的服务
 2。独立的进程  包括我们 比如说一个asp.net core webapi 它其实是有一个 netcore一个进程 在里面去运行

  问题2:soa流程不清楚，当然这只是个例子，还有很多概念不清楚。概念流程不清楚
 3.轻量级通信  这个轻量级通信 我们所讲的是在各个微服务之间 他们互相的调用 在soa原先他们走的是一个soap，甚至中间还挂了一个ejb的一些很重的一些东西 他们之间的交互， 而微服务之间呢 各个服务之间呢 是轻量级通信一般有两种 一种我们叫文本的一种协议就是像json http的轻量级协议，另外一种是二进制的 更轻的 叫probuff这种  包括我们可能会涉及到的一些grpc调用这种轻量级通信，在微服务之间呢互相调用

 4.基于业务的能力，如果说我们来进行领域划分也好 或者团队的来划分的 他都是基于业务的  ，不会把一块业务甚至是按照团队来拆分， 而不是说按照技术栈来 前端放到一块，后端放到一块，移动端放到一块，而这个微服务呢 主张是用户划一块， 做用户的这群人 包括了前端 后端 然后开发 测试 运维等等都在这个里面，他们自己去维护这组服务， 把这群人根据业务归属 划分到一起， 这是我们说的基于业务能力
 5.独立部署 也就是说每个服务它其实都是可以支持独立部署， 这个在互联网方式下，迭代也会非常的快，我们用户这块，要改一个，改完就发了， 不会等其他的一些东西
 6.无集中式管理 在微服务的这种情况下，它本身也是这样的一种区别， 

 问题4：采用新方案带来的优缺点， 也是事务的演进 不存在这样的概念
 大家简单的来理解下微服务，因为本身实质上它指导的东西 也非常少 但是其实我们 讲微服务 它本身来说是一个很抽象的概念 也没有很多具体的东西 但是后面我们会在做的过程中， 因为我们在进行了这种微小 服务化拆分之后，所带来的一些问题 会引发一些在架构上的一些补充，包括你的  因为问题引发出来的 比如问题 在你服务化之后 我们有一个很重要的问题 我们可以给大家举一个特别形象的例子， 
 就比如说
 var userService=new UserService();
 userService.GetUser(1001);
 这么简单的一句话呢？ 如果我们是在单体架构内，就是一个程序内的话，它是没有问题的， 一旦你是一个远程的调用 如果你是一个 service  call的话  这个情况就特别多，就是我们会出现你的额各种  因为你现在不是在一台服务器上，而是你通过一台服务器去调用另外一台服务器的问题，你的不可控因素就会增加很多， 你不知道会发生什么问题？ 比如说另外一台机器cpu爆了。内存爆了，或者说网络中断了， 或者那个服务down了， 我不知道 会引发很多问题，正式因为这种服务化之后所带来的问题就是 这样之后带来了很多问题， 所以才会导致 微服务所引发的一些问题 带来开发上的一些复杂度 我们来看下 它都带来的那些问题。 上面的例子只是其中的一个，

 微服务带来的问题,既微服务带来的挑战
 1.分布式所带来的问题， 大家都知道分布式带来很多问题，如问题追踪，测试 ，部署 监控 分布式事务（一致性）这些都会在微服务架构里面出现  测试我们会引用容器，在本地快速  因为 你想你有很大一微服务之后，如你只测试你自己的微服务 一旦你的微服务有其他的依赖的微服务的话， 那么你测试起来 必须报另一组服务也启动，所以相对单体来说， 你一下运行就可以把所有的都运行起来，不会出现什么依赖还没有启动之类的，所以在这边会产生这样的一些问题，
 2.服务治理 还有服务变多了之后会出现 服务治理的问题，比如说我们现在有一百个服务 我们怎么样 在客户端那边 怎么样去调用 不可能是有100个地址，直接都丢给客户端，这100个地址是干什么的 是否是可用的状态，这就是服务治理上做的 服务发现和服务注册 包括服务的跟踪 都会遇到这样的一些问题，
 3.开发难度加大 聚合查询 还有一个是在开发上遇到的比较大的问题是 聚合查询， 导致开发难度加大，体现在聚合 也包括分布式事务，

 了解到这些情况后，我们再结合自己的要做的项目架构，我们未来会拆分成几块 有用户 通讯录 项目 消息 我们还多了一个推荐， 在我们的项目里不是有机会嘛 我自己的项目和别人 及系统推荐给我的项目， 现在我们至少有5个api，还有一个元数据    元数据就是什么呢？就是我们的省市区等基础数据 我们把它单独放到一个地方， 因为这些确实是可以被通用的  现在至少说我们会有6块微服务

 什么时候应该实践微服务？两种说法，一种是架构是被演进的 跟着你的业务一步一步的走， 当然也有人说架构是设计出来的 就是设计成什么样? 就做成什么样？ 当然我会更倾向于就是说架构是演进出来的
 这里会有一个图表 x轴和y轴的一个表  我们这样来衡量 一个维度是复杂性 一个是我们的生产力， 复杂性x轴，生产力y轴，项目最早期的时候 一个人就可以搞定很多事情 从零开始的时候， 就会很快 ，做新项目都会很多，当你的项目做的越来越复杂 加了很多业务的时候， 你的代码可能就会 越来越难加新功能 加新功能越来越慢，这个其实就是由于我们的复杂性都导致的， 
 问题5： 为什么我不能得到这样的结论呢？ 事前很难想到，看到后又觉得很简单。 如越来越难加新功能 加新功能越来越慢，


 问题6:如何自己总结出事情的演进 逻辑，乃至结果，
 单体架构随着业务复杂度的增加，生产力从一个很高的位置递减，直到不可收拾
 微服务相对来说它把它全拆小了，同时独立部署，它的生产力都是接近平衡的，当然他一开始就比较高，

 从图中可以直接看出走势。 做出判断 在交汇点之后 就要采用微服务，之前采用单体架构   所以在早期迭代业务的时候采用微服务就很痛苦， 你会发现本来你很快半天就可以搞定的事情，你在微服务架构下，要写好多服务 测试起来也比较麻烦 而且你还不是那么稳定， 在你的基础设施不是那么完善的时候，你的监控，服务之间的调用，很多的组件， 你的监控都没有起来特别容易出问题，万一它挂了 你这边也不会知道，你也不知道什么原因，在单体的情况下，往往发生的比较少，即使发生了 也你比较容易去察觉到，，所以在这种时候呢

 我之前 在最早开始 其实我写了两套我们的项目代码 第一套我是最开始是微服务架构， 大家可以简单看下，跟eshoponcontainers 架构其实比较像，我们拆了6个微服务 也就是6个api，当然这6个api之间是没有互相引用的， 只是被放在一个解决方案之内， 
 
 问题7：察觉出问题
 我们写着写着发现 不太对劲，因为写的太慢了。因为我们 这种微服务架构不知道会写到什么时候， 虽然写起来也挺开心的， 但是呢会比较慢， 对早期业务迭代呢 不太好，因为你还不确定 你的业务会改成什么样子， 哪些是有用的，哪些是没有用的 而且你都花了这么大精力 投入在上面，其实对于真正的生产团队来说 公司来说 是不划算的，  
 所以我后来又把它改成了单体架构，  我们下节课会给大家讲 因为我在想 在做单体架构的时候。 打这个框架的时候，我就想到说， 早晚我们肯定是微服务架构， 那我现在要写一套单体，

 问题8：有前瞻性的思考
 有没可能说 到时候转成微服务时，它的成本会变得最低呢？ 所以带着这个问题， 我来自己做了这样的单体架构，它是 可能我们把它变成微服务架构非常的简单， 
 并且它可以利用微服务中的一些特点 比如说它 在微服务下 因为你被拆开之后， 在单个体系下你可以运用不同的数据库 就是持久化，那么可以结合你数据库或者持久化工具一些特性 其实可以加快你的效率的，比如说我们在通讯录这块， 通讯录的结构 它用mongo比较合适， 为什么这么来讲呢  一个通讯录其实很简单，他不需要跟其他的表去join，它就是一个用户一个通讯录， 这个通讯录里面你可以看你自己的手机， 每个人有一个自己的通讯录，这个通讯录里面其实存放了很多的用户，有一个contactbooks的集合， 一个用户会有一个contactbook 然后这个contactbook里有很多contacts 就是他的联系人，如果你在关系型数据库里面你可能要建一张表  

 问题9: 为什么会这么做  理由要知道的很清楚？
 我给大家简单讲下为什么会这么做， 在关系型数据库上 你有contacts这样的一个表，表有几列列 
 id  userid  contactid
 1   1001    1002
 2   1002    1001 如果是要表示互为好友
 这样是有人建议的 你在做通讯录的时候的 存储关系，这样如果你要查询1001的好友 你的userid=1001  这样有多少条通讯录，就有多少条数据，包括你查询的时候， 性能就是问题，（因为多条数据，而mongo只有一条数据，） 除了查询可能还有存在 因为我们再添加用户的时候 肯定会说这个人是不是我们好友，做个判断， 那我就需要全局查找， 还有我们在做批量用户添加的时候 一次性添加5 6个的时候， 你可能还需要在内存当中做一些运算 就是把数据全部都取出来， 第一个你首先要把这个人的好友都取出来， 取出来之后呢 你要看 哪些是它的好友，哪些不是他的好友，不是他的好友就添加，是他的好友就不添加，有很多逻辑的运算 你需要在内存当中单独的去处理，但mongodb本身呢 针对一个docment 如果他下面是有集合的话， 本身在查询语句上就已经支持 包括在查找 添加 或者批量添加时候， 它可以类似于上面的逻辑操作，  支持把数组内不存在的数据添加，已经存在就不添加，并且呢原生就支持所说的场景，所以在这种时候呢 肯定在通讯录这块选择用mongodb来做数据存储，，我们在做单体架构时候呢 其实，我其实也想用到这种思路，我想加速我的开发， 我想一个多小时就把我的通讯录api 就写完， 很快的写完 性能上也很多， 在早期我都不想用redis去存储了， 所以直接用mongodb来做， 要考虑到我是否能利用到它的优势，所以在这种情况下，我们的单体架构其实也可以这样去拆分是，所以下节课给大家讲下 面对微服务的单体架构的开发，



