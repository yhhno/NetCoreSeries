开始时间3:40

问题1：效率的提高。

本节课给大家讲下演进单体，演进针对的是业务量和用户量的增长来做的扩展，从扩展上来讲，我们之前在讲微服务的时候，对扩展有个定义，即使xyz三个轴来扩展， 我们来看下，
首先是大家非常容易理解的x轴  所谓的复制（复制有问题，静态变量 本地local缓存和状态不同步，不一致，此时要采用这样方案的话，不能共享的东西就不能使用了，如静态变量） x轴扩展它主要包括两个东西，一个是负载均衡 
第二个y轴扩展， 其实比较好理解，其实就是通常我们讲的根据业务来划分，像我们的服务化就是soa，以及微服务里面的拆分 都是在y轴扩展的这个体系内， 比如说像我们的项目，我们把系统拆分为用户 通讯录 项目 消息等就属于y轴的扩展，，
在这种情况下呢 在进一步 之后 我们还会一层更高维度的扩展， 叫Z轴扩展 此时就为三维图形，能够应对的复杂度就更高， 怎么来理解z轴扩展呢， 他其实来说， 就想比如说 我们在部署这块，阿里在云服务器的例子， 阿里在云服务器上有不同的区域，不同的区域上它的价格是不一样的，那么你比如说华东1 华东2和华北 在选服务器的时候，它会把你跳转到不同的地方去进行价格的计算包括订单的结算，那么它的业务不一样，同时他所处的部署，运行结构 不同的区域涉及到的用户量 包括它的整个下面的部署都不一样，就是业务不一样，部署也不一样，所以这个时候呢 他就会扩展出来 在我们的这个基础之上， 比如说  像这种扩展，不同区域 业务不一样，他所要求的部署基础设施就会结合我们的x轴扩展，最终它的整个系统就会变得更庞大，
我们接下来再来给大家说下，具体落地到网站或应用上架构的扩展 在最开始上节课讲单体架构的时候，  最开始有一个浏览器 web服务器 db服务器 可能还有一个文件服务器， 当然最早我们也没有文件服务器，文件只是保存在项目目录下的一个文件夹下如static/images，static/js static/css 统称静态文件，这些文件他在我们的浏览器里面  比如说我们打开一个浏览器 它是属于加载之后 会占用浏览器请求 包括带宽，我们来看下 这涉及到 整个一个网站的一个请求的过程，如果我们从性能优化的角度来讲，从这个地方可以去入手，浏览器中 按F12，看一个网站的请求，比如说我们刷新下，它首先第一个请求，拿到的是整个html，他其实拿到的是一个文本， 有多大呢  6.2kb，下载时间是125ms，整个过程 我们可以看到整个过程有4个阶段， 请求 发送 等待 等待的过程就是服务器响应的过程，最后是下载，  整个过程是125ms， 这个浏览器呈现完的时间 大概是2s的样子，因为它下载到html之后开始渲染，渲染过程包括浏览器对html的解析，css和js加载，每遇到一个文件包括所有遇到的静态资源，从html的最上面开始 css 图片包括js文件 统一称为外部的静态资源， 每一个都会发起一个请求，去下载，这个请求在不同浏览器是有不同限制的，在ie下是6个还是8个，大家可以去查下，需要了解下，当你文件过多的时候，会出现阻塞，浏览器同时只能请求6个请求， 比如说有过多的图片，一次只能6个，完成后再下一批6个，这个也就说要尽量减少浏览器的请求数，所以在css这块会出现静态资源合并，然后哦以及包括图片的雪碧图，这些技术都是用来优化浏览器页面渲染的这个过程，就是在网站性能优化这块，渲染之后，
第一步你可以做的很简单东西就是把静态文件不要放在web服务器上，这叫做静态资源隔离，就是分出来，所以在这个地方一般会有一台文件服务器，file server 或者说叫静态资源， 可能这个时候你就诞生了一个域名叫image.xxx.com 所有的文件地址，换成这个域名，它的请求呢 第一个流量不会通过webserver来请求，而是通过file server来请求，第二个就是说 流量包括其他的一些处理 iis处理 这些都不会跟webserver发生冲突 至少不会抢占资源， 其实我们所干的一件事就是把职责分出去， 我们第一步拆的是静态资源， 拆完之后，图片域名只有一个的话，同时有6个请求时候，它是会出现排队，所以有些网站会做这样的事情， 它会搞好几个file服务器，这些服务器的静态资源批量复制，他们是一样的，然在在前端请求时 随机出现不同的服务器，  大家去阿里的服务器都可以看到，当然现在的做法是统一把这些静态文件 全部放到七牛或者又拍云上， 因为他们还能帮你做cdn， 所谓cdn就是不同的区域部署不同的节点，然后根据当前用户所在的位置，自动判断定位到和用户最近的节点，比如说你北京  访问上海的一个网站的话， 它中间的距离会涉及到传输， 就是 像你下载的时候，时间就会加长，，虽然你服务器是处理完了 包括请求的时间和下载的时间都会有所影响，静态资源服务器她花的时间基本上都是在下载上，浏览器不需要做太多的解析和渲染，服务器也没有，主要是网络这一块， 用第三方云的加速， 对网站的性能也是有提升的， 
那我们现在把静态资源分出去以后呢， webserver就只剩下 web程序了， 现在是mvc项目，所以我们还可以进行的扩展是，前后端分离 就是api化，  因为我们在webserver 这里还完成了razar 大家知道razar是一个视图引擎，这个视图引擎是会把我们的数据和html视图做一个渲染，他也在做一个html的渲染，我们其实就会做一件事情就是， 把渲染这个过程压力抛到客户端上去，让你自己来做渲染， 服务器端就不处理这个事情了，这个时候我们就会用到spa，spa由vue实现，用jquery也可以，在最开始我们用 knockout/vue这样之类的前端框架  它来帮我们做数据和html的绑定和渲染，然后我们只负责api ，在这个时候做这样的扩展进一步减轻了webserver（现在是api）的压力，
接下来，后面之后，我们会有两层的压力会来，一层是api服务器的压力 一台服务器处理不了那么多的并发请求，你的api服务器直接会有cpu的预算 ，所以你的内存和cpu不能够满足的情况下， 就会诞生多台api服务器，当有了多个api服务器之后，我们就需要加上负载均衡，，负载均衡在这个地方会把下面的多台的api服务器进行一些流量分发， 这就属于x轴扩展，第二层，当加入了负载均衡之后，所有的压力都会跑到dbserver上，dbserver它是一个单一的东西，他没有办法说，去做水平复制，你复制一个dbserver出来，之间就需要做一些数据同步，所以我在dbserver这个地方呢做的第一件事情就是copy两份， 这个时候一般最早做所的就是读写分离，一台读，一台写，将读和写的流量来进行区分， 读库和写库，主库和从库 当然他们之间需要数据同步的机制， 然后，我们接下来要看我们的并发从哪一步来，可能通常情况下，某一些读可以进行一些api的监控，看看那些api就是他的请求量特别多， 我们可以在这些地方加上第三方东西， 比如说redis，这时候他解决的是读的api请求的压力，他不走数据库，而是先走redis缓存， 因为他是内存级别的，减轻了数据库的压力，读缓存到一定阶段之后，我们还是没有办法去缓解的话，到最后我们就是要必须去分db了，当然大部分redis这块，缓存如果我们设计的好的话，也可以解决不少的问题， 然后读的这块 这个地方在中期的时候 我们的解决办法也可以做到不要那么快的去用到分库分表，其实分库分表会对整体的架构 包括业务 api上会产生一定的影响，我们这个时候在它上面可以采用cqrs的结构 你的写是要进行排队的，当然cqrs我在这里简单给大家介绍下，读的时候 我们走redis缓存，写的时候，会有一层队列 如rabbitmq，在写的时候会来一个command，这个command时候api服务器这边封装好的， api服务器把每一个请求，封装成一个command，然后把command丢到queue上，command到队列里之后呢，下面会有很多台worker，因为你的apiserver分开之后，你的写的压力 当然比如说秒杀，下订单的东西可以放到这里， 就可以可以用这种方式把写的压力给它分摊出去， 但是这个时候你的客户端可能需要做处理，因为这个相当于异步的，你可能就是说apiserver 把command放入到队列里，apiserver就返回了， 那你客户端需要做一些处理，比如说你订单这个状态显示，你现在应该是处于一个处理中 在处理中  会进行到一个什么状态，它后面要处理之后会  这个worker其实会干什么，其实会拿到你这个command之后， 会把它写到写库，，所以cqrs的写，特别是command这块，因为query它是会分开到另外一边， 然后把写的command通过队列，以及worker的方式来把它写到数据库里面， 这种也是对写的大量并发进来的一种缓冲，最后就  一般情况下我们做到此时的处理时，后面再进行扩展就是要把db分开或者表分开，最开始我们可以做的其实就是  分库分表有两个维度， 也是会有我们讲的横向扩展和纵向扩展，我们在做横向扩展的时候，其实跟根据业务来拆分api 有点像 （拆分用户，项目等），它呢是进行这样拆分的  用户库 项目库 联系人库等， 这样子之后， 其实对db来进行分流，此时整体db的同步就不需要了， 这种横向扩展之后，其实我们可以相应的来说可以来做api的一些拆分 配合分库，这样之后，大家能够理解，已经是有一些微服务的概念， 具体下一节课完整讲，在这种情况下进行db的拆分， 就进一步对db来进行分流， 因为流量大量大了之后， sqlserver还是单节点，很容易挂，流量一上来你的cpu就100%，，所以我们在一定阶段后，不得不去做这种拆分，，db拆分完之后呢，在最后的一步扩展，如用户的数据库一个表有几亿条数据或更多的数据量时，你怎么对表进行拆分了。这个就是数据层面的拆分了，数据库的纵向拆分， 所以数据库分横向和纵向拆分，，基本上到这个时候，我们把我们所要讲的这种架构 基本上已经到了一定的维度 ，当然你的数据库拆分之后，会涉及到比如说聚合查询，你有些查询既涉及到用户有涉及到项目的时候 如何来做，一般是有两种方案的一种是聚合 聚合服务把数据库再整一个数据库出来把他两个都同步到聚合数据库，再通过聚合数据库进行查询，另外一种方式是，冗余就是把一些用户数据冗余到项目里去，直接在项目去查询，相对来说， 看你的场景，因为我们刚刚讲的聚合之后，你会涉及到一定的延时，你查询起来会比较方便一点，但是会有一些延时，而且数据库同步机制也要想好，第二种就是说你冗余之后，同步的问题 你的用户数据冗余在项目库里，你的用户数据如何改了之后你怎么样去同步 ，这个其实也会涉及到CQRS或者你用事件 event来进行处理，这个我们在cqrs的项目时，进一步给大家讲，，关于演进我们 就是架构的升级只能粗略的给大家讲下，在中间会提到一些知识点，大家可以进一步结合文章来或者博客来进行一些补充，当然罗马大道非一日建成，，所以我们也需要不断的再去加深自己的了解和认知，从单体架构到 服务化api化 到扩展水平扩展 xyz轴的扩展， 到数据库的横向和纵向扩展，一步一步的将我们的系统，从小到大，去发展的过程 自己可以想一想 如果你的系统在发生这样的变化的时候 ，你做的这些事情，你需要弥补的哪些知识点是你现在不掌握的，比如数据库主从呀 他们之间的复制呀 然后cqrs的同步用的队列 以及其他的聚合服务 数据库同步机制 然后以及分库之后的 数据库分布性事务怎么来处理， 都是一些问题  大家 可以进行一些研究和讨论，这节课讲的是架构的演进和在扩展上可以去做的一些事情，，下节课会给大家讲微服务的介绍，其实在分库分表之后，和微服务有点接近了，我们更多的是把概念提取出来更准确些


还有一个问题就是写数据库的压力，写数据库的压力怎么来