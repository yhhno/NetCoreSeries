
任务59：微服务拆分与界限上下文的确定 是如何进行的？ 要学会？
问题1：遇到问题，新东西，不拥有的的东西，第一感觉是怕？决不能是怕,是去战胜，去分析，去分解，例如看到画的微服务图和类图， 怕啥呢，一看到陌生的东西就怕， 没道理呀，我是从零开始学的，都没学过 怕啥呢？
问题2：撤回有点多。 这是啥原因造成的，其实后面不顾虑什么，直接加快速度，其实错误的不多，是不是有点不专心，慢悠悠的阿 是不是有点不积极。
问题3：如何找需求，如何根据需求做功能？ 如何继续找需求，如何继续加功能?  =》自己去设计？
问题4：逻辑呀，事物的逻辑呀，不明白，它就是一对文字和傻傻的你。 =》观察别人的设计
问题5：自己之前所有的经验和认知都是很简单的，不复杂的，而我们需要的是复杂的，
问题6：灵与肉分开，真正的自由，没开化的人，不被眼前事困扰，不知道该怎么自己对自己？讲究




这节课我们主要讲的是  上节课因为我们已经讲过了关于用例 也就是我们画了用例，用例画完之后，我们基本上来说，那个还是处于业务分析的阶段， 就是我们需要对我们的业务有比较清晰的认识，我不知道大家有没有已经 就是通过我们不断地去演示原型以及通过这个用例图，流程图，来去了解我们  就是 假如我是产品经理的话，我这样给你们去，或者我是一个架构师，那么这样去演示我们即将要做的这个产品 它的业务逻辑，你们是否能够充分的get到 所有的 所讲的点，因为只有在这个基础之上，你才可以在接下来的 后面当中，进行一些 我们叫开发上的一些设计， 那么业务分析完之后，我们来做这个开发上的设计，因为我们这次呢 要做的是一个微服务的架构，所以我们在做微服务架构之前呢，最重要的一步就是做好 这个 服务的拆分，那服务的拆分呢，其中又有一个比较重要的 或者是说比较有 大家比较认可的一种方式，就是按照领域的拆分，那也就是我们所讲的DDD，当然其实在微服务架构上来说，并不是说我们一定要用这种方式，它还有很多其他的一些方式来进行服务的划分，那当然 领域的 按照领域的这种方式来，bounded context 就是因为在我们之前讲什么是微服务的时候，它就是 一个 讲到的 说 一组很小的服务，那么是松散耦合的，并且是独立部署和运行的，就是用领域上下文的这个界限来划分的 一组服务，所以我们在这里呢，这节课我们就开始来对我们现在这个业务进行领域划分，然后我们接下来，并不是说我们就一定会按照ddd完整的这种方式，去实现我们的每一部分的服务，但是我们可以用ddd的分析方法，将我们的微服务进行拆分，所以我们在这个地方画了一个图，已经画好了，因为，这个就不耽误大家时间，，
我们根据我们之前的做出来的原型呢，来划分了四个领域，那首先我们讲领域，领域就是说， 说一个界限，那这个界限就定义了 就是我们这块具体做什么内容，这个系统它是做哪些的，是这样，那么我们在我们这个系统里面首先有很多领域，领域它分为  就是有一个叫核心的一个领域，除了核心以外，有一些非核心的领域， 非核心的有包括 分为了我们叫 一个是用来做通用的领域 通用的领域那么当然从它字面意思上理解就是，很多地方都可以用的这种，那当然所以在这个地方，他们之间会有一些交互，核心领域就是我们这个产品所特别，最需要关注的一块领域，也就是说没有它我们这个产品可能就不是我们要做的这个产品了，，而我们自己来定义一下我们这个， 这个其实核心与非核心 其实大家  它是一个引起一个重视程度，所以我们可以看，那么在我们这个系统里面。我们做了是一个关于项目的一个产品，所以我们可以说关于项目这块，它是我们的核心领域，，没有它我们就不行，而用户呢，这个身份就是这块呢，包括你的用户资料或者这块，他其实是一个通用的领域，也就是说，整个app基本上都会有，
其实有了用户和项目这块呢，这个产品就像点样子了， 对不对，至少我们可以有用户登录进来，然后呢，可以去创建项目，这个其实也是我们最开始设想的一个产品，就是从最开始点出发，我们想要解决的问题就是，省去用户在微信朋友圈上面去转发各种用文字性质来展示它们的项目的一个问题，一天发三遍，然后没有固定格式，就是由这个问题引发而来的，所以我们的核心领域是项目，是用户，那么有有了这两个领域，其实我们最开始所设想的功能就已经完成了。 
而后来在我们这个延伸的时候，就想到了说， 哎，我原来还有一个功能是我发在朋友圈 ，我的朋友看到之后呢，它就会来问我，但这个时候，我其实要单独发给我的朋友呢，其实我还需要复制一下，那我们后来就想到了，我们干嘛不干脆就把我们这个好友的关系给加进来，对不对，那这个时候其实就是说我可以直接，当然有一种情况就是我们现在同样也支持把你这个项目分享出去，分享到你的微信好友，那这是一种，另外一种呢其实我们想到为什么我还一定要分享，做这样的一步动作呢？那我可不可以在我们的app里面，有一个自己的好友关系，它有这样的一个关系出来之后，我这个项目创建之后，我可以选择性直接就让它可见或者非可见，因为只有这样的话呢，我们这个app才有一个，如果我只做项目和用户身份这两个域的话，他其实是一个工具，大家能够理解，就是我只是做了一个很简单的app工具而已，来提升了一个效率上 就是解决了它操作效率上的一个问题，
而在通讯录加入进来之后，就是好友之间加入进来，其实我们这个产品，就有了一些关于用户的概念，用户之间会产生 行为和交互，他并且可以扩散出更多的用户出来，这个时候它会演变成一个产品，它会有一些数据在流通，不仅仅只是有自己的数据，那我可以看到我朋友的数据，我朋友可以看到我的数据，有了这样的好友关系进来之后，这个app才算是活了。所以呢，我们后来加入通讯录这个领域，当然它只是做一个支撑，有了它之后呢，就是在 基于这个  项目推荐的这块能够将它  
这个项目推荐，我们原先讲了三种类型的项目推荐，一个是好友，一个是二度好友，一个是系统推荐，这三个级别的推荐，而这个推荐呢，是将我们整个app变得，在它有了项目 用户身份和通讯录之上，它是用来 在我们刚刚讲了引入通讯录之后呢，这个项目推荐能够将我们这个产品再提高一层，就是做到自动的推荐，有了通讯录你创建一个项目，我就帮你推荐给你的好友，你的好友在它的主页就可以自动看的到，并且呢我还会给它发一些提示，通知，短信之类的，提示他来看，这个时候只要是它感兴趣的，它立马就可以看得到。这时候等于把我们这个整个东西都打通了，，同时我们后来考虑到说，你的好友可能不够，一度好友可能不够，我们可以让你的二度好友，也可以看到，这是一个扩深，而第三个呢，系统推荐呢，是给哪些他可能在 它的朋友圈里没有这个可以去可以去创建项目的人（也就是说它朋友圈里看不到项目），因此我们给它系统推荐，这个时候也就是说哪怕你不是一个 你朋友圈没有这样的人的话，我们依然可以让你，你只需要设置你所关注的一些行业或者是融资的轮次之类的，或者你感兴趣的这块，所以都可以让你得到信息，基本上来说，由这四个领域共同组成了我们这个系统，
当然我们刚刚在最早的时候，我们给大家看的这里还有一个消息，对不对，包括元数据，其实元数据就是我没把它划分成一个领域，因为这个其实有点像应用层面的东西，就是我只是提供一些基础数据而已，那么另外一个是我们的消息，消息呢其实他也是应用层的东西，我没有把它当做业务层的东西，因为我们只是在这块呢，给它一个消息提示，其实是为了我们的这个 让整个系统转起来，不发消息，其实你推荐出来之后，这个用户如果登录到这个 它的主页的话， 也可以看的到，，所以消息这个东西呢，它不是一个必须的，当然我们这个聊天不一样，，聊天它是有一个单独的功能，它其实被我们放在通讯录里面， 就是你有这个通讯录，联系人之间相互聊天，那这是他自己的一个东西，那我们的这个消息呢，它其实是放在应用层，也就是说 当做像邮件呀，这样的一些东西一样的，这个就是我们的这个领域，
在了解完这个领域之后， 我们每一个领域里面其实像它来说呢 ，它就是一个界限上下文，我们叫bounded context，在每一个界限上下文当中，我们会有这个实体（entity），还有这个valueobject，如果大家在看实现领域驱动这个本书的话，就会讲到，有这个valueobject 还有domain service，但是我们这次呢，其实不会整的那么复杂，因为大家去看这个domain entity和value object还有包括这个domain service的话呢？其实相对来说已经是有一些比较难懂的概念在里面，特别是 entity和value object如何去做区分，当然我们在这个里面呢，我们有了我们的界限上下文之后，其实我们微服务的框架就出来了，也就是我们在这个地方如何去做，划一部分 用户出来，划一部分通讯录出来，划一部分项目出来，以及这个我们的推荐机会，至少这四个我们要出来，对吧，
接下来的问题就是在每一个 这个领域内 我们做哪些 做什么样的事情，这个就是属于我们一个界限上下文之内 要确定的一个东西，所以我们来 接着看下，我们在这个之前的这个里面已经画好了，有一个实体，这样的一个引用关系，当然我们可以继续在那个里面去用，这个其实是根据我们这个功能来的，也就是  比如说，我们首先来看 我们的这个项目这块，它的界限上下文里面包含哪些东西，看一下， 好，项目这个里面呢，我们会做哪些事情，首先我们是创建这个项目，对不对，我们看这个 project 假如这是一个界限上下文的话呢，我们会在里面放什么？里面会有我们的这个 项目project，然后我们的这个项目会有我们这个查看的 ProjectViewer，查看了它的项目，还记得我们查看项目的时候，是需要签一个协议的， 对不对， 所以当你签完协议之后，别人也知道你看了，所以这个项目一定会有一个项目查看的，然后同时呢 还会有一个projectContributer，有了这两个，至于这个项目，我们如何来 去做实体层面的设计呢，我们可以放到后面，但是我们现在 从这个业务上来理解， 我们的project他还有那个东西呢？还有一个是 但是这个东西呢？ 其实它不应该出现在这里，它可以是一个值对象，或者是一个 或者直接放到project里面来实现其实也是可以的，它叫我们的 projectvisibleRule，这是什么东西呢，就是我们在创建项目的时候，这个时候选择的一个叫是否可见 设置权限这个地方，那它其实 我们把它单独 放出来，在这个地方（新页面），因为它这个里面会选择一个是否公开以及选择一个tag 就是标签，当然我们把它放出来了额，这是设置的一个projectvisibleRule，是否可见的一个规则，那么当然，我们其实也可以把这个projectvisibleRule放到project里面，他到底怎么样 就是，他甚至还有 包括我们后期会对这个模型 项目的模型进行拆分，这个时候我们就不完全是按照这个Aggregate，因为像domain 像完整的 就是完全按照DDD的这个思想来讲呢，一个领域下，它其实只能有一个根，就是聚合根，就如果说，这个是一个聚合的话，那么他就会只有一个聚合根，但在我们这个地方呢，其实大家可以看到我们聚合根就是我们的项目，我们只能够通过我们的项目 来访问 这个项目下的查看的人，这个项目查看的Contributer，以及这个项目查看下的visiblerule，

问题2：没有照搬硬套，而是重在理解。
如果我们完全按照ddd的思想来做呢，其实反倒把我们整个项目整复杂一些，所以我们在这个时候呢 ，我们就可能只是用DDD做了一个划分，然后我们后面引入了CQRS，在模型处理这块，业务处理这块呢？我们有一点偏向于这个，有一点偏向于，就是，根据这个model来查询和处理，因为我们有时候可能会直接干一些，就是直接查这个projectviewer的一些事情，这个时候其实在标准的DDD思想，是不建议这么干的，它其实必须通过你的project才可以去操作到你的 下面的一些东西，就是聚合根，包括他的持久化，也是直接通过project来进行持久化的，那我们先把这四个东西放到项目领域图内，
这是我们的项目领域，包括我们的这个通讯录领域，其实它很简单，就是一个contactbook，和我们这个contact，当然这个contact 这两个其实相对来说，就  它两个还属于一对多的关系，一个contactbook会对多个contact，
那我们用户身份领域这个就不用说了，它就是一些用户 用户的信息在这个里面，然后支撑呢就是我们的projectRecommend，recommend其实它就是一个，其实它里面就包括一些项目的信息，它是什么呢？它就是我们机会列表里面的信息，其实它里面带了一个projectid我们在最终 就是说，机会这个地方点进去 其实会跳转到这个 项目的访问者访问的页面，可以说是一个 不是一个ditiao的页面 它是一个缩略图的一个信息的概念，
那接下来，其实我们在详细的看一下，就是我们的这个 更细致的 一些类图，我们如何 比如说我们现在来确认功能的话，我们如何来做，一部分是我们的这个用户，在我们这个用户这块我们要干的事情其实就是说，第一个就是对我的资料进行产看和修改，就这两个，然后呢同时它会有一些bp，我们把bp放到用户这个地方，就是，它不是跟项目走的，因为在我们这个里面，我们的bp是怎么来的呢?我们的 bp它是可以通过一个选择，个人下面它有一个，我们在后面就是把bp直接跟个人相关的，因为我们的bp是从微信那边来的，我们看一下，这个，导入商业计划书，是从微信上把它的pdf这些东西，通过应用来打开，通过保存过来，直接保存在它的个人信息下面了，所以我们会有一个bp，然后呢有一个标签，这个用户标签呢是他自己的一个标签，因为它在给好友打标签的时候呢，是有一个列表的，在我们的这个，看一下个人信息他人打标签，就在这个地方，下面会有一个 是这个 用户自己的一个列表，然后 这个时候来选择，同时在这里写一个没有的这个标签，它还可以去进行新增，所以这个标签，其实是跟着用户走的，它不是跟着联系人走的，联系人走的那个标签在另外一个地方，就是联系人会有一个，只有你打上去之后，这个才是属于联系人的标签，在你没打上去之前呢，其实属于用户的标签，什么时候变成好友的标签呢，在这个地方，查看好友主页时显示的标签，是好友的标签，其实就是用户自己维护一个标签列表，然后呢给好友打标签的时候，从这个列表里去选择，，大家理解下这个逻辑，
然后，我们接下来呢，就是，继续看我们的 那个类图，所以我们的用户这块呢，会有一个用户自己的一个便签列表tags，我们这个箭头啊，画的是不准确的，没有完全按照uml的这种一对多，或者多对一的这种组合依赖的关系，我们就直接拉了一个箭头，然后大家可以通过这个list<string> 来看到它所对应的tag，然后还有bpfiles也是这个list<bpfile>,properties是什么东西呢，这个其实是一个简化的应用，在表设计的时候我们做的是， 因为在个人信息这块呢，有好几个东西都是从元数据选择项里面来的，比如说我们的这个投资行业，他其实是一个一对多，我们不可能就是每一个这样的东西都建一张表，投资规模也是多选的，然后这个投资阶段也是多选的，这三个呢，我们就把它放到一张表里面，

问题1：撤回的太多了，
每个用户就是说它可以 有一个叫userProperty就是属性的一个表，这个表里面其实就是对应的是 key value。就是你的text和value，key呢就是说，比如说我们是一个，投资行业放一个key，然后它里面会选多条value，然后投资规模也是，所以说我们就用这张表把这三个 这个字段都放到进去，放到用户属性里面了额，它是一个多个选项出来的，而公司，职位，地区，地区我们直接放到这个user的这个实体上，就是entity上，那当然我们还会有一个user的id，基本上这样的话，就是我们把用户的这些信息呢，全部给容纳进去了，

问题3：微服务带来了什么？
但是我们这个地方是没有写用户的这个行为的，大家可以理解成我们这个地方要做的就是一个贫血模型的一种做法，当然这是一种 在标准ddd上，它不推荐这么做，但其实呢，我们在微服务架构下，拆小之后呢，其实这么做是效率最高的，这就是微服务所带来的 就是说他对于原有规则，固有规则，打破的一些地方，就是它并不是说一定要 强行按照某一种这个模式或者什么东西去用,而是说在业务规模被拆开之后的 简单的这一块，单块内容之下呢，适合你这个业务的，就是最好的，所以我们这个地方呢也可以简单来操作，，
包括我们像这个contactbook和contact 其实就很简单，我就是会有一些添加或者修改 删除包括打标签，打标签其实就是打在contact上面的tag，我们就有一个list<string>,就这样，所以在这块呢，我们后面在mongodb的时候，就是在他具体下一块选型的时候呢 我们其实在早期的时候，就关注到它的边界就可以了额，你甚至可以把这块拆开之后，他后续怎么样写 其实我们是不需要管的，反正他负责了我们之前所定义的就是在联系人这块它的领域下一些功能，
然后，接下来是我们项目，我们的项目就是会有项目的这些字段信息全都在这，同时呢会有我们的这个可见范围，然后项目的属性，项目的属性给user的属性会很像，因为在我们的项目里面也会有这个多个 多选的一些东西，然后会有一个viewer和Contributer，viewer呢，其实就是把用户的这个一些信息也丢过来了额，然后Contributer呢多了两个，一个是是否关闭，这个在我们的业务逻辑里面，一个是这个 它的这个 参与的类型是一个投资顾问还是一个合伙人，、
好，然后接下来是我们的这个projectRecommend，就是我们机会，这个机会呢，其实它里面就是放了项目的一些基本信息，在我们的这个，机会里面，就是他直接拿过来了，然后同时呢，我们在这个projectReferenceUser，这是什么呢，这是我们的二度好友的时候，中间的用户，我们会把它跟recommend推荐的时候关联，我们把用户的信息也拿过来了额，所以大家看到，这种结构下，我们拆分过之后，最大的一个问题是什么呢，我们想要 因为我们在原先 如果在单个系统内，我们是可以 比如说，就是在用户出来之后，我们的contact里面，其实这个里面，我们看到contact是有名称有电话，有头像，还有公司 title这些信息全部是user里面的信息，我们现在 相当于是做了复制，有两种方式，因为在我们之前说，第一个微服务给我们带来的难题就是聚合服务，或者说跨 我们不能做join查询了，那么在这个时候，如果我们要做这种就是数据的这种查询的话呢，有一种方式就是我们在这个地方contact加引用，这里只保留这个，比如说只保留userid就可以了额，那这个时候呢，我们在查这个contact信息的时候，我们来看，在我们的这个联系人 好友列表的时候会显示这个头像名称公司和title，那这几个字段呢，我们需要查了这个联系人之后，在查一遍我们的用户这个api，那其实相对来说，就是说我们要查一下contact的api和再查下user的api，那这种是一种跨服务查询，就是查了两个个服务，然后还有一个呢，就是说像我们的项目，项目的这个里面其实也会有user，大家看到他本身这个里面，会有一个projectviewer和projectContributer，我们也拿过来了，就是放到这边，做了冗余，否则我们也要和contact一样，查项目的时候，在查一遍user的api，，还有一个是我们的projectrecommend，recommend这个地方其实，大家看到一个fromuserid，就是说你这个推荐是从那个用户推荐过来的，那我们也把这个名字拿过来了，第二个拿过来我们把项目也拿过来了，就是项目的这个，我们大家看到，在我们的机会里面不是显示了项目的标题，项目的logo，还有一些简单的介绍，这几个字段，我们也冗余过来了额，拿过来了额，然后这个referenceuser包括了user的信息，也拿过来了额，这就是说我们没有在去做这个，因为我们不能做表join，那另外一种方法就是用 通过api service来查，recommend service来查user的service，project也来查user的service，同时呢recommend呢还有查这个project的service，这是一种情况，就是说在你做这种查询的时候，就是你的这个，服务呢，就是比较会容易， 第一个就是说我们做了两次查询，这个性能呢可能会有问题嘛，性能上有问题，第二个呢是说你的微服务的这个服务的结构或者说引用呢，其实相对来说 会变的相对来说比较难以管理，那这是一种方式，就是我们跨服务的时候，这些信息 数据怎么处理，一种是我们说做api直接查询的方式，还有一种是我们现在所用的数据冗余的方式，直接把数据拎过去，到时候，但这就产生 带来一个问题就是这个用户信息他如果变了，会怎么办？因为我们在这个地方就需要一个权衡，就是这些数据到底变动的频不频繁，如果不频繁我们是可以这么做的，就是说因为我们要做一次同步嘛，如果它经常变动，你去做同步或者同步本身也比较多，还不如去用  牺牲一点 就是说因为你这样比较麻烦，就是时间上来说 加速用户查询的这块东西，那当然我们还好，我们的用户信息呢，它的手机号，它的姓名，公司这块其实是变动没那么频繁的，因为你也不可能一年跳好几次槽，也不太可能，所以我们这个用户信息，其实变动没有那么频繁，特别另外一个是我们的项目信息，我们的项目信息，基本上来说，不给他修改的，就是，所以我们在这里所做的选择是，对于我们现有的信息做了冗余，然后在用户修改的时候，修改这些信息的时候，我们进行同步，所以这个同步就会出现在当用户资料发生变更的时候，我们会把它发消息，发到其他的域下面，发到这个projectrecommend这个域和project 还有contact这三个域下，他都会接到用户资料更新的信息，然后把自己这块内容给更新掉，这是一种处理方式，那刚给大家讲了，这两种方式，各有利弊，就是前者有性能的损失，后者呢是会增加大量的一些同步的这个操作，否则你的信息会不同步，那么特别是还有可能保存一些就是修改之前的一些信息，这个问题呢，我们可以在延伸的讨论下，包括大家看一下在微服务这种模式下，会有哪些其他的方式来可以解决这个问题，
好，这样完之后呢，因为我们大致上把业务分析了，进行划分了，所以，我们在接下来会先开始去实现一个我们的微服务当中用的这个身份的这块，因为我们需要有token，就是会先把token给做掉，做完之后呢，我们会开始把用户这块给先做掉，因为，现在其实我们 大家看到我们还没有设计api，其实我们api完全可以在， 单块里再去设计，就是拿到，这块的功能我们已经确定下来，我负责用户这块，用户这块有什么功能，里面再进行设计，所以，我们接下来就，会开始 其实顺序来说，我也可以 先开始写user的service，最后在把这个认证这块给加上，因为认证我们最后会用oauth 也集成进去，那我们会先开始写，这个 那么我们就先开始写用户服务，我们先把用户服务给写好，写好之后，我们后面再看什么时候去写我们 统一的登录 安全这块的，好那今天我们呢先给大家讲了这个我们的领域的这个划分，接下来每一个领域里面，界限上下文里面 它的实体，它的实体以及它的这些信息，这个地方我们没有完全参照DDD的这个思路， 因为第一个就是那块我们 我们还是这块倾向于说，根据业务把我们的模型建立出来，他跟我们这个做的一些，表设计呢还是比较像的，有点像我们直接就是说来做表，但是功能上其实我们来说 在这个下面就是说 一些基本的业务分析，有了这个表出来了，

问题4:对分析的情况有个评价，基本的认识。
然后，可能在项目这块，这个地方时候，我们会用到这个CQRS，就是我们会把查询和写分开，只有这块是最复杂的，也是我们最核心的，我们会在这块用cqrs，他也是被查和更新的最多的，联系人和推荐这块，推荐这块完全是一个查，他写全部是我们系统产生的，就是系统后台给你推 算出哪些推荐过去，用户只会在这里进行查询，project这个地方是读写最多的地方，所以我们会在这个地方用到，CQRs 查询和写分离出来，然后用户这块也比较简单，contact这块呢也不复杂，好，今天先到这里，接下来课程会先实现用户这块的服务，当然这块会非常快，所以我们在下节课的时候，就会把他完成，